---
title: "Illumina .biom analysis"
author:
  - name: Simon Grimm
    url: {}
date: 2022-11-14
description: |
categories:
draft: false
output:
  distill::distill_article:
    self_contained: false
    dev: svg
    toc: true
editor_options:
  markdown:
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  cache = TRUE,
  autodep = TRUE,
  cache.comments = FALSE,
  dpi = 300
)
```

# Background

Here I will analyze initial Illumina runs which were submitted in
October 2022.

We will work with [.biom files](https://biom-format.org/), acquired from
a CZID analysis of our data (link
[here](https://czid.org/my_data?currentDisplay=table&currentTab=samples&mapSidebarTab=summary&projectId=4788&showFilters=true&showStats=true&updatedAt=2022-10-07T18%3A28%3A46.867Z&workflow=short-read-mngs),
only available when given access. Reach out to simon\@securebio.org if
you do not have access)

# Introduction

### R packages

We start by loading all required R packages:

```{r}
# set of data analysis and viz tools
library(tidyverse)

# file system helpers
library(fs)

# specifying locations within a project
library(here)

# microbiome analysis helpers
library(biomformat)
library(speedyseq)

# plotting helpers
library(cowplot)
library(patchwork)
library(ggbeeswarm)

theme_set(theme_cowplot())
```

We then set the folder containing the `.biom` file as our `here`
directory.

```{r}
illumina_data_path <- here("data")
dir_ls(illumina_data_path) %>% path_file
```

### Data import

We now import the BIOM file (Combined Microbiome File.biom)

```{r, error = TRUE, eval = FALSE}
biom <- path(illumina_data_path, '2022_11_14_Illumina_pilot_nt_r.biom') %>%
  read_biom()
```

Note, if we try reading in the file as directly exported from CZID, we
get an error:

    Error in validObject(.Object) :
      invalid class “biom” object: type field has unsupported value

This error arises because the 'type' of the data object defined in the
JSON-formatted contents of the `.biom` file isn't valid as per the BIOM
format v1.0 specs, see
<https://biom-format.org/documentation/format_versions/biom-1.0.html>.

We can see this by opening up the file and looking for the type argument
towards the beginning; or looking at the top items in the list after
reading in the file with a JSON parser.

```{r}
biom_json <- path(illumina_data_path,
  '2022_11_14_Illumina_pilot_nt_r.biom') %>%
  jsonlite::read_json()
biom_json %>% head(9)
```

We can fix the file by changing the type from 'Table' to something
valid. It doesn't actually matter what we use:

> While type is a required entry in BIOM tables, the BIOM format itself
> does not change for different data types (e.g., OTU Table, function
> table, metabolite table). This information is included to allow tools
> that use BIOM files to determine the data type, if desired. (Caption
> for Additional file 5 in @mcdonald2012theb)

<https://academic.oup.com/gigascience/article/1/1/2047-217X-1-7/2656152>

For now, let's use 'Taxon table'.

```{r}
biom_text <- path(illumina_data_path, '2022_11_14_Illumina_pilot_nt_r.biom') %>%
  read_file
stopifnot( identical(biom_text %>% str_count('"Table"'), 1L) )
biom_text_fixed <- biom_text %>%
  str_replace('"Table"', '"Taxon table"')
write_file(
  biom_text_fixed,
  path(illumina_data_path, '2022_11_14_Illumina_pilot_nt_r_fixed.biom')
)

```

The above chunk reads in the BIOM file's contents as a single string,
checks that '"Table"' appears only once (in the field where it is set as
the type), then replaces it with '"Taxon table"'), then writes the
string as a new BIOM file. We should now be able to load the corrected
BIOM file with the biomformat package,

```{r}
biom <- path(illumina_data_path, '2022_11_14_Illumina_pilot_nt_r_fixed.biom') %>% read_biom() %>%
  print
```

Note: For most objects in R, the `print()` and `glimpse()` methods
silently return the object as well as printing information about it.
Adding a `print` or `glimpse` call at the end of a variable-assignment
pipe chain is a succinct way to save an object and show some info about
it.

### Creating a phyloseq object

The abundance (count) matrix, sample metadata table, and taxonomy table
can be extracted with three corresponding functions functions from the
biomformat package.

We'll tackle these one at a time. First, the abundance matrix.

#### Abundance matrix

```{r}
abun <- biom %>% biom_data()
abun %>% class
abun %>% dim
```

The abundance matrix is stored as a sparse matrix from the Matrix
package. That is fine for now, though phyloseq will want a standard
(dense) matrix. Next we will extract the sample metadata.

#### Sample Metadata

```{r}
sam <- biom %>% sample_metadata()
sam %>% class
sam %>% head
sam %>% glimpse
```

The sample metadata is a standard data frame with rownames giving sample
ids, and the taxonomy information is stored as a list. Notice how all
the variable names are in snake case except for one. This is apparently
because the CZID BIOM exports its own standard variables as snake case
(though shows them otherwise in the online interface), but leaves custom
variables unchanged. **It is convenient to standardize all variable
names to snake case**; an easy way to do this is with the function
`janitor::clean_names()`.

```{r}
sam <- sam %>%
  janitor::clean_names() %>%
  glimpse
```

Next, the taxonomy table, or what the biomformat package calls the
'observation metadata'.

#### Taxonomy table

Note, when using glimpse we observe that taxonomy level 2 (under
'Bacteria') is blank. Might be worth investigating why that is.

```{r}
tax <- biom %>% observation_metadata()
tax %>% class
tax %>% head(2)
tax %>% glimpse()
```

```{r}
?biomformat::observation_metadata
```

We can see that here we have a list, with one element per taxon. The
documentation for `biomformat::observation_metadata` indicates that this
function may return a 'data.frame' rather than a list, if it is able to,
but does not say under what conditions that will be the case. Ultimately
we want a data frame (or tibble). The following code chunk checks which
we have, and if we have a list, tries to turn it into a data frame by
spreading out the taxonomy vector of each list element into a table.

```{r}
tax_tmp <- biom %>% observation_metadata()
if (is.data.frame(tax_tmp)) {
  tax <- tax_tmp %>% as_tibble(rownames = '.otu')
} else {
  tax <- tax_tmp %>%
    enframe(name = 'feature_id') %>%
    unnest_wider(value)
}
rm(tax_tmp)
tax %>% glimpse
```

To understand this table further, we can first look at the first column.
This contains the entire taxonomic structure of one organism in one
variable, like so:

`Bacteria;NA;Proteobacteria;Alphaproteobacteria;Rhizobiales;Xanthobacteraceae;Azorhizobium;Azorhizobium caulinodan`

The following columns then show all the taxonomic information broken
down by different taxa levels:

```{r}
glimpse(as_tibble(tax[1:3, 2:9]))
```

To facilitate downstream analysis, it is helpful to so some cleanup:

-   Replace the taxonomic ranks with the standard NCBI rank names (see
    an example [NCBI taxonomic
    record](https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=9606))
-   In cases where the rank is missing/unassigned, replace the empty
    string with NA <!--  -->

```{r}
rnks <- c('superkingdom', 'kingdom', 'phylum', 'class', 'order', 'family',
  'genus', 'species')
colnames(tax)[2:9] <- rnks
# use NA for missing ranks
tax <- tax %>%
  mutate(
    across(everything(), ~ifelse(. == "", NA_character_, .))
  )
tax %>% glimpse
```

Now let's import all three tables into a single `phyloseq` object. This
involves converting each individual table into the corresponding class
from the `phyloseq` package, and then combining these into one
phyloseq-class object.

```{r}
ps <- phyloseq(
  otu_table(abun %>% as.matrix, taxa_are_rows = TRUE),
  sample_data(sam),
  tax_table(tax)
)
```

Note that we had to first coerce the abundance matrix to a standard
dense matrix; we also needed to tell phyloseq that taxa corresponded to
rows in the matrix.

# Basic data checks and stats

(Comments from here on out are by Simon)

Our `phyloseq` object consists of several tables, one of which is our
sample metadata:

```{r}
ps %>% sample_data() %>% glimpse
```

Understanding how many individual species are covered by each sample
gives us an initial large scale picture of how samples differ. We can
thus add a column for our sample metadata consisting of the sum of all
individual species:

```{r}
ps <- ps %>%
  mutate_sample_data(.,
    sample_sum = sample_sums(.)
  )
sam <- ps %>% sample_data %>% as_tibble
tax <- ps %>% tax_table %>% as_tibble
```

It will also be interesting to compare groups of samples by their
experimental protocols. For this, we can add a column to our sample
metadata, consisting of experimental classes:

!!! Make experiment class assignments robust.

```{r}
experiment_class <- c("peg_preciptation", "peg_preciptation", "ceres", 
                         "peg_preciptation", "ceres", "ceres", "amicon", 
                         "peg_preciptation", "amicon", "ceres", "amicon", "amicon")

ps <- ps %>% 
  mutate_sample_data(
    experiment_class = experiment_class)
```

```{r}
ps %>% t

```

As visible in the crude table below, there are multiple samples with
very small species amounts, while other samples contain more than
150'000 individual species. The samples with very low species counts are
controls (A-C, CU-C, PC) and the CERES filtered sample.

```{r}
sam %>%
  ggplot(aes(sample_sum, fill = experiment_class)) +
  scale_x_log10() +
  geom_histogram()

sam %>%
  ggplot(aes(sample_sum, fill = experiment_type)) +
  scale_x_log10() +
  geom_histogram()
```

```{r}
?fct_explicit_na
```

**QUESTION:** Can we walk through the code below?

```{r}
taxon_stats <- ps %>%
  as_tibble %>%
  mutate(across(superkingdom, fct_explicit_na)) %>%
  with_groups(c(.otu, superkingdom), summarize,
    prev_1 = sum(.abundance >= 1),
    prev_10 = sum(.abundance >= 10),
    total = sum(.abundance),
    proportion = mean(.abundance / sample_sum)
  )
```

```{r}
taxon_stats %>%
  pivot_longer(-c(.otu, superkingdom)) %>%
  ggplot(aes(value, fill = superkingdom)) +
  facet_wrap(~name, scales = 'free') +
  scale_x_log10() +
  scale_fill_brewer(type = 'qual') +
  geom_histogram()
```

## Taxonomy

NCBI taxonomy has recently received changes in some prokaryotic phylum
names. Let's check to see which version of phylum names are being used
here, by seeing whether a Bacteroides species' phylum is listed as
'Bacteroidetes' (old name) or 'Bacteroidota' (new name).

```{r}
tax %>%
  filter(genus == 'Bacteroides') %>%
  slice(1)%>%
  glimpse
```

If we look at [this taxon in NCBI
taxonomy](https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=1263047),
we can see that NCBI has adopted the new phylum name 'Bacteroidota';
however, here we see the old phylum name. This suggests that CZID is
currently using an older version of NCBI prior to the name change.

see -
<https://ncbiinsights.ncbi.nlm.nih.gov/2021/12/10/ncbi-taxonomy-prokaryote-phyla-added/> -
<https://www.the-scientist.com/news-opinion/newly-renamed-prokaryote-phyla-cause-uproar-69578>
<!--  -->

We can now also look at the fraction of each taxa level which is
classified. In total there are 12447 classified species:

```{r}
tax %>%
  pivot_longer(-.otu, names_to = 'rank') %>%
  with_groups(rank, summarize,
    features_classified = sum(!is.na(value)),
    features_total = n()
  ) %>%
  mutate(
    frac_classified = features_classified / features_total,
    rank = factor(rank, rank_names(ps))
  ) %>%
  arrange(rank)
```

This analysis points to some notable features of the data. For example,
not every taxonomic feature has a superkingdom. Let's take a look at
some of those 'species' that don't:

```{r}
set.seed(42)
tax %>%
  filter(is.na(superkingdom)) %>%
  select(superkingdom, kingdom, genus, species) %>%
  slice_sample(n=20)
```

As we see, there are some sequences that are classified as cloning and
expression vectors.

What about 'species' without intermediate ranks?

```{r}
tax %>%
  filter(!is.na(superkingdom), is.na(family)) %>%
  select(superkingdom, kingdom, phylum, family, genus, species) %>%
  slice_sample(n=20)
```

Different than before these sequences seem to match NCBI records that
aren't well annotated (e.g., "Uncultured Bacterium")

Lastly we can look at how species break down by superkingdom:

```{r}
tax %>%
  count(superkingdom) %>%
  mutate(fraction = n / sum(n))
```

# Analysis

## Taxonomic composition overview

**QUESTION:** What would be most useful here?

## Recreating the Rothman et al 2021 Figure 4 using Illumina data

Rothman Figure 4:
([source](https://journals.asm.org/doi/full/10.1128/AEM.01448-21))

![](images/paste-58683FF7.png)

Prep: Note, it is often helpful to filter out some samples and taxa
prior to doing some downstream analysis.

-   Normally we would remove samples with very low read counts, since
    the low read counts can be a sign of experimental issues with those
    samples. But here, low read count samples are tap water control
    samples and the CERES filtered sample, which we want to analyze as
    well:

```{r}
ps %>% filter_sample_data(!sample_sum > 1e3) %>% sample_data %>% .[["experiment_type"]]
```

-   We also want to subset to just viruses for now (the Rothman analysis
    also only considers viruses)
-   Remove species with under 10 reads, and those occurring in fewer
    than three samples, which will speed up calculations and likely make
    our results more meaningful since these identifications can easily
    be spurious.

!!! Check how the last point interacts with the abundance table at the
end of this document

```{r}
ps_subset <- ps %>%
  filter_tax_table(superkingdom == 'Viruses') %>%
  filter_taxa2(~ sum(. > 0) > 2 & sum(.) >= 10) %>%
  print
```

Using this subfilter, `ps_subset` only includes are only there are only
`r ntaxa(ps_subset)` species being considered, compared to `r ntaxa(ps)`
in the entire CZID output.

```{r}
ntaxa(ps_subset)
```

taxa, while `ps` includes

```{r}
ntaxa(ps) 
```

taxa.

### Bray-Curtis NMDS ordination (Panel A)

There are many ways to do this; here I'll use the `ordinate()` and
`plot_ordination()` helper function from phyloseq to create the NMDS
plot using the Bray-Curtis community dissimilarity metric. Note, that it
is important to manually normalize the abundances to have the same total
in each sample (e.g. by normalizing to proportions, as done here),
otherwise the different total counts across samples will affect the
results.

```{r}
nmds <- ps_subset %>%
    #speedyseq::transform_sample_counts(~ . / sum(.)) %>%
    ordinate(method = "NMDS", distance = "bray", trymax = 50)
ps_subset_ord <- plot_ordination(ps_subset, nmds,
  color = "experiment_type", type = "samples"
) +
  labs(color = 'experiment_type')
ps_subset_ord
```

### Alpha diversity (Panel B)

We can compute Shannon alpha diversity index for each sample in a
variety of ways:

-   `phyloseq::estimate_richness()`
-   `vegan::diversity()`
-   Performing the calculation ourselves from the definition <!--  -->

```{r}
shannon_index <- otu_table(ps_subset) %>%
  orient_taxa(as = 'cols') %>%
  vegan::diversity()
shannon_index %>% head
```

Note that we needed to reorient the abundance matrix (i.e. OTU table) to
have taxa corresponding to columns, as this is what functions in the
vegan package expect. We can tell that we used the correct orientation
because the resulting diversity values are in a named vector where the
names correspond to the sample names. If we had passed the matrix in the
incorrect orientation, then the vector names would be the taxa names.

Let's add the Shannon index and the experiment type to a copy of the
sample data called `sam_plot`,

```{r}
sample_data(ps)
```

```{r}
ps_subset <- ps_subset %>% 
  speedyseq::mutate_sample_data(
    shannon_index = shannon_index,
    experiment_class = experiment_class)

# We will have to make the creation of the experiment_class more robust in the future.

```

then create the plot,

```{r}
??ps_mutate
```

```{r}
p_div <- ps_subset %>% 
  sample_data %>% 
  ggplot(aes(y = shannon_index, x = experiment_class,
      color = experiment_class)) +
  geom_boxplot(outlier.shape = NA) +
  geom_quasirandom() +
  expand_limits(y = 0) +
  # scale_color_manual(values = colors_countries) +
  labs(x = 'experiment_class', y = 'Shannon index') +
  theme(
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
    legend.position = 'none'
  )
p_div
```

Note, I'm plotting the data points over the box plots, since it is
useful to see the scatter when we're working with a relatively small
number of points like this.

Note, I suggest using the exponential of the Shannon index and plotting
on a log scale), so that the numbers shown on the axis are in terms of
effective number of species.

Now we can also redo our ordination, labeling by 'experiment_class'.

!!!

Results here seem quite jumpy, plausibly due to a lack of normalization
and samples with very low read counts (3 controls plus filtered Ceres)

```{r}
nmds <- ps_subset %>%
    #speedyseq::transform_sample_counts(~ . / sum(.)) %>%
    ordinate(method = "NMDS", distance = "bray", trymax = 50)
p_ord <- plot_ordination(ps_subset, nmds,
  color = "experiment_class", type = "samples"
) +
  labs(color = 'experiment_class')
p_ord
```

### Relative abundances (Proportions) (Panel C)

In the actual Rothman figure, the abundances for a set of viruses are
shown; the particular viruses were picked based on an analysis to
determine viruses that vary across treatment plant, using the ANCOM R
package. I may do that in a future version of this script, but for now
I'll just pick the 10 most abundant viruses by average proportion.

First, get a data frame for plotting, with the proportions of all taxa
alongside the original read counts,

```{r}
x <- ps_subset %>%
  as_tibble %>%
  with_groups(.sample, mutate,
    proportion = .abundance / sum(.abundance))
```

Next, get the top 10 viruses by median proportion. We can do this
various ways, e.g.

```{r}
top_viruses1 <- ps_subset %>%
  speedyseq::transform_sample_counts(~ . / sum(.)) %>%
  orient_taxa(as = 'rows') %>%
  otu_table %>%
  apply(1, median) %>%
  sort(decreasing = TRUE) %>%
  head(10) %>%
  names

top_viruses1
```

The above doesn't work due to the line
`speedyseq::transform_sample_counts`. Dropping it makes the code work
but returns a list of viruses that look spurious.

```{r}
top_viruses2 <- ps_subset %>%
  #speedyseq::transform_sample_counts(~ . / sum(.)) %>%
  orient_taxa(as = 'rows') %>%
  otu_table %>%
  apply(1, median) %>%
  sort(decreasing = TRUE) %>%
  head(10) %>%
  names

top_viruses2
```

We can also try a third alternative, which isn't working in its current
form.

```{r}
top_viruses3 <- x %>%
  with_groups(.otu, summarize, across(proportion, median)) %>%
  slice_max(proportion, n = 10) %>%
  print %>%
  pull(.otu)
identical(top_viruses2, top_viruses3)
```

```{r, fig.dim = c(10,5)}
p_prop <- x %>%
  filter(.otu %in% top_viruses2) %>%
  mutate(
    across(genus, fct_reorder, proportion, .fun = median, .desc = TRUE),
  ) %>%
  ggplot(aes(x = experiment_type, y = proportion,
      color = experiment_class)) +
  facet_wrap(~genus, nrow = 2, scales = 'free_y') +
  scale_y_log10() +
  geom_boxplot() +
  geom_jitter() +
  labs(y = 'Proportion', x = 'experiment_type') +
  theme(
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
    legend.position = 'none'
  )

p_prop
```

Note, I've ordered the facets as decreasing in median proportion.

### Put the panels together

Putting multiple panels together is often very easy with the patchwork
package loaded,

```{r, fig.dim = c(10,10)}
(p_ord + p_div) / p_prop +
  plot_annotation(tag_levels = 'A')
```

This plot could definitely benefit from some extra fiddling, to adjust
the spacing and colors etc.
