---
title: "Illumina Kraken 2 Import"
author:
  - name: Simon Grimm
    url: {simongrimm.com}
date: 2022-11-14
description: |
categories:
draft: false
output:
  bookdown::html_document2:
    toc: yes
    toc_float: yes
    toc_collapsed: yes
    df_print: paged
    code_folding: show
    theme: lumen
    warning: false
    cache: true
    echo: false
    autodep: true
    cache.comment: false
    dpi: 300
editor_options:
  markdown:
    wrap: 72
---



# Introduction
Here we *import*, *format*, and *clean* kraken2 results of our Illumina data. This report isn't meant to show results, but rather to show the steps taken to get towards a dataset with which we can analyse our Illumina sample composition.

TODO: Link taxonomic kraken2 reports to every original kraken2 report.

Do this with an R function that merges the taxonomic report with the original report, joining on the lowest taxonomic rank.

# Setup

## R packages

```{r, message=FALSE}
# set of data analysis and viz tools
library(tidyverse)

# file system helpers
library(fs)
library(googlesheets4)

# specifying locations within a project
library(here)

# microbiome analysis helpers
library(biomformat)
library(speedyseq)
library(vegan)

# plotting helpers
library(cowplot)
theme_set(theme_cowplot())
library(patchwork)
library(ggbeeswarm)
```

## Defining directories

```{r, message=FALSE}
biom_data_path <- here("data/czid")
metadata_data_path <- here("data/metadata")
kraken_data_path <- here("data/kraken_reports/kraken2_standard_16gb")
taxonomy_data_path <- here("data/taxonomy")
output_data_path <- here("output")
project_path <- here('../illumina_pilot')
```

## Data import

### Metadata
We first read in metadata for all samples of the experiment exp4.006. This table is in a manually curated google sheet, available under this [link](https://docs.google.com/spreadsheets/d/1a7BHgb0_NPgey61IHlsF-RP2_EBhAUyW4e377oHQs1k/edit):
```{r, message=FALSE, warning=FALSE}
#Reading in metadata from this google sheet link:
sample_metadata <- read_sheet(
  'https://docs.google.com/spreadsheets/d/1a7BHgb0_NPgey61IHlsF-RP2_EBhAUyW4e377oHQs1k/edit') %>%
  janitor::clean_names() %>%
  glimpse
```

### Kraken2 reports

#### Context

We now read in our Kraken2 reports. Kraken2 is a tool for assigning taxonomic labels to unassembled (raw) DNA sequences. Kraken2 outputs a report for each sample, which contains the taxonomic labels assigned to each sequence, as well as the number of sequences assigned to each taxon. The reports are available in the `data/kraken_reports` directory.

In this analyses we work with Kraken2 runs, using a 15 GB RefSeq database, called Standard-16, available [here](https://benlangmead.github.io/aws-indexes/k2). Previously we used a smaller RefSeq database (~7.5 GB) called Standard-8 or Minikraken, viewable [here](https://benlangmead.github.io/aws-indexes/k2#:~:text=to%20use%20it.-,Kraken%202%20/%20Bracken%20Refseq%20indexes,-Starting%20Fall%202020)

#### Kraken2 report structure

A typical Kraken2 report looks like this:

```
 97.51	1082761	1082761	U	0	unclassified
  2.49	27631	210	R	1	root
  2.20	24479	26	R1	131567	  cellular organisms
  2.00	22186	542	D	2	    Bacteria
  1.14	12682	258	P	1224	      Proteobacteria
  0.54	6049	99	C	1236	        Gammaproteobacteria
  0.22	2488	2	O	72274	          Pseudomonadales
  0.16	1766	2	F	468	            Moraxellaceae
  0.15	1639	135	G	469	              Acinetobacter
  0.04	409	324	S	40214	                Acinetobacter johnsonii
  0.01	85	85	S1	1242245	                  Acinetobacter johnsonii XBB1
  0.03	313	3	G1	196816	                unclassified Acinetobacter
  0.01	146	146	S	2004646	                  Acinetobacter sp. WCHA55
  0.00	47	47	S	2079596	                  Acinetobacter sp. SWBY1
  0.00	19	19	S	1879049	                  Acinetobacter sp. WCHAc010034
```

There are six columns:

 - `clade_coverage`: Percentage of fragments covered by the clade rooted at this taxon
 - `fragments_covered`: Number of fragments covered by the clade rooted at this taxon
 - `fragments_assigned`: Number of fragments assigned directly to this taxon
 - `rank_code`: A rank code indicating (U)nclassified, (R)oot, (D)omain, (K)ingdom, (P)hylum, (C)lass,
(O)rder, (F)amily, (G)enus, (S)pecies. Taxa that are not any of these 10 ranks have a
rank code that is formed by using the rank code of the closest ancestor rank with a
number indicating the distance from that rank. Ex. Lampyrinae has a rank code of
“F1” because it is a subfamily one step below Lampyridae (the firefly family).
 - `ncbi_tax_id`: The Taxonomic ID number from NCBI
 - `scientific_name`: Indented Scientific Name (the number of spaces indicates  taxonomic depth)

#### Reading in reports

First, we read in the full directory paths for all kraken2 reports.
```{r}
report_fns <- path(project_path, 'data/kraken_reports/kraken2_standard_16gb') %>%
  dir_ls(glob = '*_kraken2_report.txt')
```
<details>
  <summary>*Code explainer*</summary>
  `dir_ls` returns a vector of file paths. `Glob` allows us to use regex, matching any file path that ends with `_kraken2_report.txt`.
</details>
```{r}
read_kraken_report <- function(kraken_report) {
  col_names <- c('clade_coverage', 'fragments_covered', 'fragments_assigned',
                 'rank_code', 'ncbi_tax_id', 'scientific_name')
  col_types <- cols(
    clade_coverage = col_double(),
    fragments_covered = col_integer(),
    fragments_assigned = col_integer(),
    rank_code = col_character(),
    ncbi_tax_id = col_integer(),
    scientific_name = col_character()
  )
  read_tsv(kraken_report, col_names = col_names, col_types = col_types)
}
```
<details>
  <summary>*Code explainer*</summary>
  Defining a function to read in a kraken2 report. We specify the column names (`col_names) and types (`col_types`), and then use `read_tsv` to read in the given `kraken_report`.
</details>
```{r}
names(report_fns) <- str_extract(report_fns %>% path_file, '^.*(?=_kraken2_report.txt)')
kraken_reports <- map_dfr(report_fns, read_kraken_report, .id = 'sample')
```
<details>
  <summary>*Code explainer*</summary>
  Here we use `names()` to assign the respective sample number to each object in the vector `report_fns`, where the sample number is in the file name within the `report_fns` path file.
  We extract the file name using this regular expression `'^.*(?=kraken2_report.txt)'`. This expression
  - returns everything before the first occurrence of `kraken2_report.txt` by anchoring the start of the string (^),
  - matching any character (.= any character, * any length of text),
  - and then stopping at the first `kraken2_report.txt`.

  Next we read in each kraken2 report into an R data table. This is done with the `map_dfr` function, which maps a function onto each element of a vector, and then combines the output into a data frame.
<details>
#### Linking kraken2 reports with taxonomic information

We now want to link the resulting kraken2 dataframe with information about the full upstream taxonomy of each taxa present in `kraken2_sample_reports`.

These full taxonomies can either be created by [Kraken]([manual](https://github.com/DerrickWood/kraken2/blob/master/docs/MANUAL.markdown#:~:text=provide%20the%20option-,%2D%2Duse%2Dmpa%2Dstyle,-that%20can%20be)), or through a KrakenTools script, kraken2mpa.py, which is available [here](https://github.com/naobservatory/KrakenTools).

```{r}
##Integrate the following code into the mag pipeline.
#<!-- for file in data/kraken_reports/kraken2_standard_16gb/*.txt
#do
#	python3 local_scripts/KrakenTools/kreport2mpa_older_version.py -r $file -o $file.mpa
#done
#
#mkdir output/kraken/kraken2_standard_16gb
#for file in data/kraken_reports/kraken2_standard_16gb/*.mpa
#do
#  mv $file output/kraken/kraken2_standard_16gb
#done -->
```

```{r}
taxonomy_fns <- path(output_data_path, '/kraken/kraken2_standard_16gb') %>%
  dir_ls(glob = '*_kraken2_report.txt.mpa') %>%
  glimpse()
```
<details>
  <summary>*Code explainer*</summary>
  Again, `dir_ls` returns a vector of file paths. `Glob` allows us to use regex, matching any file path that ends with `_kraken2_report.txt.mpa`, thus matching all taxonomy reports.
</details>
```{r}
read_kraken_taxonomy <- function(kraken_taxonomy) {
  col_names <- c('full_taxonomy', 'fragments_covered')
  col_types <- cols(
    full_taxonomy = col_character(),
    fragments_covered = col_integer()
  )
  read_tsv(kraken_taxonomy, col_names = col_names, col_types = col_types)
}
```
<details>
  <summary>*Code explainer*</summary>
  Defining a function to read in a kraken2 taxonomy report (txt.mpa). We specify the column names (`col_names) and types (`col_types`), and then use `read_tsv` to read in the given `kraken_t`.
</details>
```{r}
names(taxonomy_fns) <- str_extract(taxonomy_fns %>% path_file, '^.*(?=_kraken2_report.txt.mpa)')
kraken_taxonomies <- map_dfr(taxonomy_fns, read_kraken_taxonomy, .id = 'sample') %>%
  mutate_if(is.character, tolower) %>%
  mutate_if(is.character, ~str_replace_all(., ' ', '_')) %>%
  glimpse()
```

Now we want to turn the full taxonomy column into several taxonomic ranks. We can do this by splitting the full taxonomy column on the |.
```{r}
#Finish explainer of code below
kraken_taxonomies_expanded <- kraken_taxonomies %>%
  mutate(
    kingdom = str_extract(full_taxonomy, "(?<=^k__)[^|]+"),
    phylum  = str_extract(full_taxonomy, "(?<=p__)[^|]+"),
    class   = str_extract(full_taxonomy, "(?<=c__)[^|]+"),
    order   = str_extract(full_taxonomy, "(?<=o__)[^|]+"),
    family  = str_extract(full_taxonomy, "(?<=f__)[^|]+"),
    genus   = str_extract(full_taxonomy, "(?<=g__)[^|]+"),
    species = str_extract(full_taxonomy, "(?<=s__)[^|]+")
  )

```
<details>
  <summary>*Code explainer*</summary>
  Positive Lookbehind (?<=c__)
  Assert that the Regex below matches
  c__ matches the characters c__ literally (case sensitive)
  Match a single character not present in the list below [^|]
  + matches the previous token between one and unlimited times, as many times as possible, giving back as needed (greedy)
  | matches the character | with index 12410 (7C16 or 1748) literally (case sensitive)
</details>

```


```{r, warning=FALSE, message=FALSE}
taxonomy_reference <- read_csv(path(taxonomy_data_path, 'taxonomy_reference.csv'), skip = 1) %>%
  janitor::clean_names() %>%
  # remove unused columns
  select(where(~!all(is.na(.)))) %>%
  mutate_if(is.character, tolower) %>%
  mutate_if(is.character, ~str_replace_all(., ' ', '_')) %>%
  glimpse
```

## Linking genome composition information with kraken2 entries

We have useful metadata about ~all viral species in the ICTV table ([source](https://ictv.global/vmr)), viewable as a google sheet [here](https://docs.google.com/spreadsheets/d/1mufrHxLlTnDR37YLnWeauXYXTm0dZKXYoPOiMemP2GY/edit?usp=sharing).

We have **three different ways** of linking viruses persent in the kraken2 reports with the ICTV table:

 1. Link entries by species name.
 2. Link virus genome composition by identifying common higher taxonomic lebels (e.g. family, genus, order, etc.) between the ICTV table and the kraken2 reports. These higher taxonomic levels would need to only have one possible genome composition state.

### Linking entries by species name

Let's try to link the viruses by species name first.

First, we subset all viral species taxonomies from the kraken2 taxonomic reports.
```{r, code_folding = "show", message=FALSE, warning=FALSE, output=FALSE}
kraken_viral_species <- kraken_taxonomies_expanded %>%
  # Extracting all Viruses
  filter(kingdom == 'viruses') %>%
  # Dropping all rows with NA values in the species column
  filter(!is.na(species)) %>%
  glimpse()
```

Then we define two functions both creating a vector, returning TRUE if a given **species** or **genus** name is present in the ICTV table.

```{r, code_folding = "show", message=FALSE, warning=FALSE, output=FALSE}
logical_virus_presence <- function(virus) {
  if (virus %in% taxonomy_reference$species) {
    return(TRUE)
  } else if (virus %in% taxonomy_reference$virus_name_s) {
    return(TRUE)
  } else {
    return(FALSE)
}}

logical_genus_presence <- function(genus) {
  if (genus %in% taxonomy_reference$genus) {
    return(TRUE)
  } else {
    return(FALSE)
}}
```

Running functions on our subset taxnomies `kraken_viral_species`. We can then combine the results to end up with a logical vector, indicating true wherever either a kraken species or a genus matches in the ICTV table.

```{r, code_folding = "show", message=FALSE, warning=FALSE, output=FALSE}
virus_present <- map(kraken_viral_species$species, logical_virus_presence) %>%
  as.logical()

genus_present <- map(kraken_viral_species$genus, logical_genus_presence) %>%
  as.logical()

virus_or_genus_present <- (virus_present | genus_present) %>%
  sum() %>%
  glimpse
```
<details>
  <summary>*Code explainer*</summary>
  | is a logical OR operator, which returns TRUE if either of the two arguments are TRUE. We can use this to combine the results of the two functions, to end up with a logical vector, indicating true wherever either a kraken species or a genus matches in the ICTV table. More on Boolean algebra can be found [here](https://r4ds.hadley.nz/logicals.html#fig-bool-ops:~:text=Once%20you%20have%20multiple%20logical%20vectors%2C%20you%20can%20combine%20them%20together%20using%20Boolean%20algebra.%20In%20R%2C%20%26%20is%20%E2%80%9Cand%E2%80%9D%2C%20%7C%20is%20%E2%80%9Cor%E2%80%9D%2C%20!%20is%20%E2%80%9Cnot%E2%80%9D%2C%20and%20xor()%20is%20exclusive%20or2.)
</details>

Doing this we find that only **`r virus_or_genus_present`** of the **`r length(kraken_viral_species$species)`** species in the kraken2 match onto the ICTV table, either by species or genus name. This equates to **`r round((virus_or_genus_present / length(kraken_viral_species$species) *100))` %** of species in our kraken2 analyses.

### Linking entries through higher taxonomic ranks

We could thus try to link genome composition to our kraken2 species', by identifying higher taxonomic ranks that are more likely to be homogenous between both ICTV and Kraken2 taxonomies. We've previously created these taxonomies this by using kreport2mpa.py; the output files are found under `output/kraken/kraken2_standard_16gb/*.txt.mpa`.

Next, we want to identify on which taxonomic level we want to link entries. We do this by figuring out which taxonomic level in the ICTV table is easily linkable while also maintaining unique genome composition.

TODO - delete the latter: As seen below there are more than 1400 species that do not have the same genome composition as other species in their genus. This means that we cannot link entries by genus, as this would result in a lot of misclassifications.

**As of now it seems we will have to link entries in various ways, as there is no single taxonomic level that is both homogenous and linkable.**



### Reflecting on what I'm trying to do here

I have now created full taxonomies for the kraken2 data. What we now want to do is link the genome composition info of the ICTV table to our kraken2 species data, either linking on species or genus. For this we
 1. String split genome composition information along into four columns containing i) single stranded or double stranded, ii) DNA, and RNA, iii) and + or - or +/-, and iv) RT or non -RT.
 2. Then we match the kraken2 data, first on species where we add all genome composition information.
 3. For sequences that do not match on species, we match on genus. Here we group_by genus, checking if any genome composition information is **ambiquous**. If this is the case, we will enter that value. If there is no value for this category of genome composition, we will return NA.


```{r}
#Pseudocode: Add four columns, each containing a single genome composition category
taxonomy_reference_split_genome_comp <- taxonomy_reference %>%
  mutate(
    single_stranded_double_stranded = str_extract(genome_composition, 'ss|ds'),
    dna_rna = str_extract(genome_composition, 'dna|rna'),
    plus_minus = str_extract(genome_composition, '\\(\\+\\)|\\(\\-\\)|\\(\\+/-\\)'),
    rt_non_rt = str_extract(genome_composition, '-rt|non-rt')
  )

#Count number of occurences for each of unique genome composition
count_subset_genome_composition <- function (taxonomy_reference_split_genome_comp) {
  #Count number of occurences for each of unique genome composition
  taxonomy_reference_split_genome_comp %>%
    count(single_stranded_double_stranded) %>%
    print

  taxonomy_reference_split_genome_comp %>%
    count(dna_rna) %>%
    print

  taxonomy_reference_split_genome_comp %>%
    count(plus_minus) %>%
    print

  taxonomy_reference_split_genome_comp %>%
    count(rt_non_rt) %>%
    print
}

count_subset_genome_composition(taxonomy_reference_split_genome_comp)

```


Linking taxonomic information to `kraken_viral_species` by species

```{r}
kraken_reports_with_taxonomies_viral_species <- kraken_viral_species %>%
  select(!full_taxonomy) %>% #Dropping full taxonomy column as information is now redundant
    left_join(
      kraken_reports %>% #Subselecting all rows of interest
        select(
          sample,
          scientific_name,
          clade_coverage,
          fragments_assigned,
          ncbi_tax_id) %>%
        mutate_if(is.character, tolower) %>%
        mutate_if(is.character, ~str_replace_all(., ' ', '_')), #Turning all character variables into snake_case
      by = c('species' = 'scientific_name', 'sample' = 'sample') #Joining on species name and sample
    )
```
<details>
  <summary>*Code explainer*</summary>
  TODO: Explain by clause
  It is important to use `by` with both `sample` and `species` as there are multiple entries for the same species in the kraken2 report. This is because the same species can be found in multiple samples. We thus need to join on the unique combinations of species and sample.
</details>
```

Adding viral genome composition info to `kraken_viral_species_complete`

```{r}

create_gen_comp_records_on_species <- function(line_species) {
  mutate(
        single_stranded_double_stranded = taxonomy_reference_split_genome_comp %>%
          filter(species == line_species) %>%
          pull(single_stranded_double_stranded),
        dna_rna = taxonomy_reference_split_genome_comp %>%
          filter(species == line_species) %>%
          pull(dna_rna),
        plus_minus = taxonomy_reference_split_genome_comp %>%
          filter(species == line_species) %>%
          pull(plus_minus),
        rt_non_rt = taxonomy_reference_split_genome_comp %>%
          filter(species == line_species) %>%
          pull(rt_non_rt)
      )
}

create_gen_comp_records_on_genus <- function(line_genus) {
  #Checking if any genome composition information is non_unique on the genus level, and thus ambiguous on the species level.
  taxonomy_lines <- taxonomy_reference_split_genome_comp %>%
      filter(genus == line_genus)
  #Checking if double stranded/single stranded is ambiguous
  if (taxonomy_lines %>% pull(single_stranded_double_stranded) %>%
  unique() %>%
  length() == 1)
  {
      mutate(
        single_stranded_double_stranded = single_stranded_double_stranded
        )
  } else {
      mutate(
        single_stranded_double_stranded = 'ambiguous'
        )
  }
  #Checking if DNA/RNA is ambiguous
  if (taxonomy_lines %>% pull(dna_rna) %>%
    unique() %>%
    length() == 1)
    {
      mutate(
        dna_rna = dna_rna
        )
  } else {
      mutate(
        dna_rna = 'ambiguous'
        )
  }
  #Checking if plus/minus is ambiguous
  if (taxonomy_lines %>% pull(plus_minus) %>%
    unique() %>%
    length() == 1 )
    {
      mutate(
        plus_minus = plus_minus
        )
  }
  else {
      mutate(
        plus_minus = 'ambiguous'
        )
  }
  #Checking if RT/non-RT is ambiguous
  if (taxonomy_lines %>% pull(rt_non_rt) %>%
    unique() %>%
    length() == 1 )
    {
      mutate(
        rt_non_rt = rt_non_rt
        )
  }
  else {
      mutate(
        rt_non_rt = 'ambiguous'
        )
  }
}






#Creating a function that adds the genome composition information to the kraken_viral_species_complete

add_species_genome_comp <- function(sample_report_line) {
  if (sample_report_line$species %in% taxonomy_reference_split_genome_comp$species)
  {
    #If the species matches `species` in taxonomy reference, we add the desired_columns to the sample_report_line
    create_gen_comp_records_on_species(species)

  }
  else if (sample_report_line$species %in% taxonomy_reference_split_genome_comp$virus_name_s)
  {
      #If the species matches `virus_name_s` in taxonomy reference, we add the desired_columns to the sample_report_line
      create_gen_comp_records_on_species(species)

  }
  else if (sample_report_line$genus %in% taxonomy_reference_split_genome_comp$genus)
  {
      #If the genus matches `genus` in taxonomy reference, we add the desired_columns to the sample_report_line
      create_gen_comp_records_on_genus(genus)
    return(FALSE)
}
}

```


```{r}
kraken_reports_complete <- map(kraken_reports_with_taxonomies_viral_species, add_species_genome_comp)
```

```{r}
#deprecated
# pull_taxonomy_rows <- function(kraken_report) {
#    desired_taxa <- template_taxonomy$taxonomy %>%
#      Extracting the lowest taxonomic rank
#      str_extract('([^__]*)$')
#    kraken_report %>%
#      filter(scientific_name %in% desired_taxa)
# }

# desired_rows <- pull_taxonomy_rows(kraken_reports)
```
<details>
  <summary>*Code explainer*</summary>
  We first extract the lowest taxonomic rank from the template taxonomy report. This is done by using the regular expression `([^__]*)$`. This expression
  - looks backward from the end of the file with `$`,
  - and eturns everything before the last occurrence of `__` by anchoring the end of the string (^) at `__`.

  Next, we filter the given `kraken_report` report to only include the rows that contain the desired taxa, by matching on their scientific name, which equals the entries lowest taxonomic rank.
</details>


```{r}
non_unique_composition_genus <- taxonomy_reference %>%
  group_by(genus) %>%
  #Filter all genera with more than one genome composition
  filter(n_distinct(genome_composition) > 1) %>%
  nrow %>%
  glimpse

composition_w_o_pos_neg <- taxonomy_reference %>%
  mutate(
    genome_composition = str_replace_all(genome_composition, '\\(\\+/-\\)', ''),
    genome_composition = str_replace_all(genome_composition, '\\(\\+\\)', ''),
    genome_composition = str_replace_all(genome_composition, '\\(\\-\\)', '')
  )

non_unique_composition_genus_w_o_pos_neg <- composition_w_o_pos_neg %>%
  group_by(genus) %>%
  #Filter all genera with more than one genome composition
  filter(n_distinct(genome_composition) > 1) %>%
  nrow %>%
  glimpse


non_unique_composition_family_w_o_pos_neg <- composition_w_o_pos_neg %>%
  group_by(family) %>%
  #Filter all genera with more than one genome composition
  filter(n_distinct(genome_composition) > 1) %>%
  nrow %>%
  glimpse

non_unique_composition_family <- taxonomy_reference %>%
  group_by(family) %>%
  #Filter all genera with more than one genome composition
  filter(n_distinct(genome_composition) > 1) %>%
  nrow %>%
  glimpse


unique(composition_w_o_pos_neg$genome_composition) %>%
  print

unique(taxonomy_reference$genome_composition) %>%
  print

non_unique_composition_family <- taxonomy_reference %>%
  group_by(family) %>%
  #Filter all genera with more than one genome composition
  filter(n_distinct(genome_composition) > 1) %>%
  glimpse


taxonomy_reference %>% glimpse



# summarise(unique_composition = n_distinct(genome_composition)) %>%
# #Checking if there are any genera with more than one genome composition
# filter(unique_composition > 1) %>%
# glimpse
```



```{r}
#How many species have attached genome composition information?
taxonomy_reference %>%
  filter(!is.na(genome_composition)) %>%
  nrow() %>%
  print

virus_or_genus_present %>% sum %>% glimpse

taxonomy_reference %>%
  nrow() %>%
  glimpse
```


















# Outdated code - ignore


```{r}
# If using VSCode You will need to switch to the bash kernel to run this.

# Or, you can try this: https://www.ncbi.nlm.nih.gov/guide/howto/dwn-records/

# for ACC in

# #Read out the first column of the file 10170_full_taxonomy.txt
# for ACC in cut -f 1 10170_full_taxonomy.txt |\
# echo
# # Remove the first line (the header)
# MK064563 MH447526 AM087120 AM087121 AM087122 AM087123 EU545650 AF440571
# do
#    echo -n -e "$ACC\t"
#    # Now we cut the taxid from the line. The taxid is between the '>' and '<' characters. -d '>' means cut on the '>' character, -f 2 means take the second field (the one after the cut). -d '<' means cut on the '<' character, -f 1 means take the first field (the one before the cut).
#    curl -s "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&id=${ACC}&rettype=fasta&retmode=xml" |\
#    grep TSeq_taxid |\
#    cut -d '>' -f 2 |\
#    cut -d '<' -f 1 |\
#    tr -d "\n"
#    echo
#  done
```

### Tax table

We could create the tax table either by inferring the taxonomy from the kraken2 reports, or by using the ictv taxonomy table. I will try both approaches.

#### ICTV Taxonomy

```{r}


#Creating a csv, both only containing usable genbank ids, and usable refseq ids.

genbank_accessions <- taxonomy_reference %>%
  select(virus_genbank_accession) %>%
  distinct(virus_genbank_accession, .keep_all = TRUE) %>% #select unique species
  filter(!is.na(virus_genbank_accession)) %>% #drop NA entries
  filter(!str_detect(virus_genbank_accession, ' ')) %>% #drop entries with spaces
  filter(!str_detect(virus_genbank_accession, ':')) %>% #drop entries with colons
  write.csv(path(taxonomy_data_path, 'virus_genbank_accession.csv'), row.names = FALSE)

taxonomy_reference %>%
  select(virus_refseq_accession) %>%
  distinct(virus_refseq_accession) %>%
  filter(!is.na(virus_refseq_accession)) %>%
  filter(!str_detect(virus_refseq_accession, ' ')) %>%
  write.csv(path(taxonomy_data_path, 'virus_refseq_accession.csv'), row.names = FALSE)

```


```{r}
#Number of rows in the kraken2 composite taxonomy dataframe
nrow(kraken_viral_species)
```



## Creating an otu table from the kraken2 reports
To get where we want we first need to take a look at how our kraken2 dataframes look like.

From this table we can see that we have a lot of information that we don't need. We only need the ncbi_tax_id and the fragments_assigned of all species. We can filter down to these columns using the select function and filter down to the species level using the filter function.

We combine these steps in a function called fun_subset_otu_table.

**ACTION** The final line of code in the function below should rename the fragments_covered column to the sample name. Using deparse(substitute(.))


## Building the phyloseq object

Now that we have both our metadata and our otu table we can build our phyloseq object. We start by creating a sample_data object from our metadata dataframe.

**ACTION** Code is not working yet. Likely due to mismatches (of unknown nature) between the otu_table and the sample_data. Also, the tax_table still needs to be created, as outlined earlier.
```{r}
#ps <- phyloseq(
#  otu_table(otu_kraken %>% as.matrix, taxa_are_rows = TRUE),
#  sample_data(sample_metadata)
#)
```
