---
title: "Illumina Kraken 2 Import"
author:
  - name: Simon Grimm
    url: {simongrimm.com}
date: 2022-11-14
description: |
categories:
draft: false
output:
  bookdown::html_document2:
    toc: yes
    toc_float: yes
    toc_collapsed: yes
    df_print: paged
    code_folding: show
    theme: lumen
    warning: false
    cache: true
    echo: false
    autodep: true
    cache.comment: false
    dpi: 300
editor_options:
  markdown:
    wrap: 72
---



# Introduction
Here we import, format, and clean kraken2 results of our Illumina data. This report isn’t meant to show results, but rather to show the steps taken to get towards a dataset with which we can analyse our Illumina sample composition. This code should also be adaptable to other datasets.

We also show how to link a kraken report with International Committee on Taxonomy of Viruses (ICTV) metadata.

# Setup

## R packages

```{r, message=FALSE}
# set of data analysis and viz tools
library(tidyverse)

# file system helpers
library(fs)
library(googlesheets4)

# specifying locations within a project
library(here)



# plotting helpers
library(cowplot)
theme_set(theme_cowplot())
library(patchwork)
library(ggbeeswarm)
```

## Defining directories

```{r, message=FALSE}
metadata_data_path <- here("data/metadata")
kraken_data_path <- here("data/kraken_reports/kraken2_standard_16gb")
taxonomy_data_path <- here("data/taxonomy")
output_data_path <- here("output")
project_path <- here('../illumina_pilot')
```

# Data import

## Metadata
We first read in metadata for all samples of the experiment exp4.006. This table is in a manually curated google sheet, available under this [link](https://docs.google.com/spreadsheets/d/1a7BHgb0_NPgey61IHlsF-RP2_EBhAUyW4e377oHQs1k/edit):
```{r, message=FALSE, warning=FALSE}
#Reading in metadata from this google sheet link:
sample_metadata <- read_sheet(
  'https://docs.google.com/spreadsheets/d/1a7BHgb0_NPgey61IHlsF-RP2_EBhAUyW4e377oHQs1k/edit') %>%
  janitor::clean_names()
```

## Kraken2 reports

### Context

We now read in our Kraken2 reports. Kraken2 is a tool for assigning taxonomic labels to unassembled (raw) DNA sequences, creating a report for each FASTQ file. These reports list the the number of sequences assigned to each taxon. The reports are available in the data/kraken_reports/kraken2_standard_16gb directory.

In this analyses we work with Kraken2 runs using a 15 GB RefSeq database, called Standard-16, available [here](https://benlangmead.github.io/aws-indexes/k2).

### Kraken2 report structure

A typical Kraken2 report looks like this:

| clade_coverage | fragments_covered | fragments_assigned | rank_code | ncbi_tax_id | scientific_name |
|----------------|-------------------|-------------------|-----------|------------|-----------------|
| 97.51          | 1082761           | 1082761           | U         | 0          | unclassified   |
| 2.49           | 27631             | 210               | R         | 1          | root           |
| 2.20           | 24479             | 26                | R1        | 131567     | cellular organisms |
| 2.00           | 22186             | 542               | D         | 2          | Bacteria       |
| 1.14           | 12682             | 258               | P         | 1224       | Proteobacteria |
| 0.54           | 6049              | 99                | C         | 1236       | Gammaproteobacteria |
| 0.22           | 2488              | 2                 | O         | 72274      | Pseudomonadales |
| 0.16           | 1766              | 2                 | F         | 468        | Moraxellaceae |
| 0.15           | 1639              | 135               | G         | 469        | Acinetobacter |
| 0.04           | 409               | 324               | S         | 40214      | Acinetobacter johnsonii |


There are six columns:

 - `clade_coverage`: Percentage of fragments covered by the clade rooted at this taxon
 - `fragments_covered`: Number of fragments covered by the clade rooted at this taxon
 - `fragments_assigned`: Number of fragments assigned directly to this taxon
 - `rank_code`: A rank code indicating (U)nclassified, (R)oot, (D)omain, (K)ingdom, (P)hylum, (C)lass,
(O)rder, (F)amily, (G)enus, (S)pecies. Taxa that are not any of these 10 ranks have a
rank code that is formed by using the rank code of the closest ancestor rank with a
number indicating the distance from that rank. Ex. Lampyrinae has a rank code of
“F1” because it is a subfamily one step below Lampyridae (the firefly family).
 - `ncbi_tax_id`: The Taxonomic ID number from NCBI
 - `scientific_name`: Indented Scientific Name (the number of spaces indicates  taxonomic depth)

### Reading in reports

First, we read in the full directory paths for all kraken2 reports.
```{r}
report_fns <- path(project_path, 'data/kraken_reports/kraken2_standard_16gb') %>%

  dir_ls(glob = '*_kraken2_report.txt')
```
<details>
  <summary>*Code explainer*</summary>
  `dir_ls` returns a vector of file paths. `Glob` allows us to use regex, matching any file path that ends with `_kraken2_report.txt`.
</details>


Then we create a function to read a in tsv-formatted kraken2 report called read_kraken_report:

```{r}
read_kraken_report <- function(kraken_report) {
  col_names <- c('clade_coverage', 'fragments_covered', 'fragments_assigned',
                 'rank_code', 'ncbi_tax_id', 'scientific_name')

  col_types <- cols(
    clade_coverage = col_double(),
    fragments_covered = col_integer(),
    fragments_assigned = col_integer(),
    rank_code = col_character(),
    ncbi_tax_id = col_integer(),
    scientific_name = col_character()
  )

  read_tsv(kraken_report, col_names = col_names, col_types = col_types)
}
```
<details>
  <summary>*Code explainer*</summary>
  Defining a function to read in a kraken2 report. We specify the column names (`col_names) and types (`col_types`), and then use `read_tsv` to read in the given `kraken_report`.
</details>

Finally, we use map_dfr to apply the read_kraken_report function to each file path in report_fns, and then use glimpse to take a look at the resulting data frame.

```{r}
names(report_fns) <- str_extract(report_fns %>% path_file, '^.*(?=_kraken2_report.txt)')

kraken_reports <- map_dfr(report_fns, read_kraken_report, .id = 'sample')
```
<details>
  <summary>*Code explainer*</summary>
  Here we use `names()` to assign the respective sample number to each object in the vector `report_fns`, where the sample number is in the file name within the `report_fns` path file.
  We extract the file name using this regular expression `'^.*(?=kraken2_report.txt)'`. This expression
  - returns everything before the first occurrence of `kraken2_report.txt` by anchoring the start of the string (^),
  - matching any character (.= any character, * any length of text),
  - and then stopping at the first `kraken2_report.txt`.

  Next we read in each kraken2 report into an R data table. This is done with the `map_dfr` function, which maps a function onto each element of a vector, and then combines the output into a data frame.
<details>
#### Linking kraken2 reports with taxonomic information

We now want to link the resulting kraken2 dataframe with information about the full upstream taxonomy of each taxa present in kraken2_sample_reports.

These full taxonomies can either be created by Kraken, or through a KrakenTools script, kraken2mpa.py, which is available here.

We picked the Python script producing the taxonomic reports with a Bash script. Let’s now read in the taxonomy reports.


These full taxonomies can either be created by [Kraken]([manual](https://github.com/DerrickWood/kraken2/blob/master/docs/MANUAL.markdown#:~:text=provide%20the%20option-,%2D%2Duse%2Dmpa%2Dstyle,-that%20can%20be)), or through a KrakenTools script, kraken2mpa.py, which is available [here](https://github.com/naobservatory/KrakenTools).

```{r, message=FALSE, warning=FALSE, echo = FALSE}
##Integrate the following code into the mag pipeline.
#<!-- for file in data/kraken_reports/kraken2_standard_16gb/*.txt
#do
#	python3 local_scripts/KrakenTools/kreport2mpa_older_version.py -r $file -o $file.mpa
#done
#
#mkdir output/kraken/kraken2_standard_16gb
#for file in data/kraken_reports/kraken2_standard_16gb/*.mpa
#do
#  mv $file output/kraken/kraken2_standard_16gb
#done -->
```

```{r}
taxonomy_fns <- path(output_data_path, '/kraken/kraken2_standard_16gb') %>%

  dir_ls(glob = '*_kraken2_report.txt.mpa') %>%

  glimpse()
```
<details>
  <summary>*Code explainer*</summary>
  Again, `dir_ls` returns a vector of file paths. `Glob` allows us to use regex, matching any file path that ends with `_kraken2_report.txt.mpa`, thus matching all taxonomy reports.
</details>
```{r}
read_kraken_taxonomy <- function(kraken_taxonomy) {

  col_names <- c('full_taxonomy', 'fragments_covered')
  col_types <- cols(
    full_taxonomy = col_character(),
    fragments_covered = col_integer()
  )

  read_tsv(kraken_taxonomy, col_names = col_names, col_types = col_types)
}
```
<details>
  <summary>*Code explainer*</summary>
  Defining a function to read in a kraken2 taxonomy report (txt.mpa). We specify the column names (`col_names) and types (`col_types`), and then use `read_tsv` to read in the given `kraken_taxonomy`.
</details>
```{r}
names(taxonomy_fns) <- str_extract(taxonomy_fns %>% path_file, '^.*(?=_kraken2_report.txt.mpa)')
kraken_taxonomies <- map_dfr(taxonomy_fns, read_kraken_taxonomy, .id = 'sample') %>%
  mutate_if(is.character, tolower) %>%
  mutate_if(is.character, ~str_replace_all(., ' ', '_'))
```
<details>
  <summary>*Code explainer*</summary>
  As done previously we read in all taxonomies into one R dataframe. Importantly we also use `tolower` and `str_replace_all(., ' ', '_')` on all characters within the dataframe. Doing this turns all text into [`snake_case`](https://en.wikipedia.org/wiki/Snake_case), a more convenient writing style.
</details>

Now we want to turn the full taxonomy column into several taxonomic ranks. We can do this by splitting the full taxonomy column on the | and using regex formulas to extract the respective taxonomic ranks.
```{r}
kraken_taxonomies_expanded <- kraken_taxonomies %>%
  mutate(
    kingdom = str_extract(full_taxonomy, "(?<=^k__)[^|]+"),
    phylum  = str_extract(full_taxonomy, "(?<=p__)[^|]+"),
    class   = str_extract(full_taxonomy, "(?<=c__)[^|]+"),
    order   = str_extract(full_taxonomy, "(?<=o__)[^|]+"),
    family  = str_extract(full_taxonomy, "(?<=f__)[^|]+"),
    genus   = str_extract(full_taxonomy, "(?<=g__)[^|]+"),
    species = str_extract(full_taxonomy, "(?<=s__)[^|]+")
  )

```
<details>
  <summary>*Code explainer*</summary>
  Explaining the Regex used here:
  The regular expression starts with a positive lookbehind: `(?<=pattern)` which starts a match *after* the given patterns. This is used to match each taxonomic rank individually, e.g. `k__` or `p__`. Excluding the rank pattern, the `[^|]` matches *any* character that is not a `|` character. The `+` matches the previous token between one and unlimited times, as many times as possible. The + thus stops as soon as it encounters a `|` character, which is the end of the taxonomic rank.
</details>

## Linking genome composition information with kraken2 entries

We now want link genome composition for all assigned species in our kraken2 results. Information about genome composition for ~all viral species can be found in a metadata table provided by ICTV ([source](https://ictv.global/vmr)), viewable as a google sheet [here](https://docs.google.com/spreadsheets/d/1mufrHxLlTnDR37YLnWeauXYXTm0dZKXYoPOiMemP2GY/edit?usp=sharing).

If this analysis is done again in the future (which is likely), make sure to check if the ICTV table has been updated.

Let’s read in the ICTV metadata table.


```{r, warning=FALSE, message=FALSE}
taxonomy_reference <- read_csv(path(taxonomy_data_path, 'taxonomy_reference.csv'), skip = 1) %>%
  janitor::clean_names() %>%
  # remove unused columns
  select(where(~!all(is.na(.)))) %>%
  mutate_if(is.character, tolower) %>%
  mutate_if(is.character, ~str_replace_all(., ' ', '_'))

```
<details>
  <summary>*Code explainer*</summary>
  As done previously, reading in using read_csv.We use `tolower` and `str_replace_all(., ' ', '_')` on all character variables within the dataframe. Doing this turns all text into [`snake_case`](https://en.wikipedia.org/wiki/Snake_case).
</details>

The ICTV metadata table contains valuable information, namely the genome composition of each viral species. This information could be really valuable for future analyses of NAO experiments.

We can link ICTV to our kraken reports in two different ways:

 1. Link entries by species name.
 2. Link virus genome composition by identifying common higher taxonomic lebels (e.g. family, genus, order, etc.) between the ICTV table and the kraken2 reports. These higher taxonomic levels would need to only have one possible genome composition state.
### Linking entries by species name

Let's try to link the viruses by species name first.

First, we subset all viral species taxonomies from the kraken2 taxonomic reports.
```{r, code_folding = "show", message=FALSE, warning=FALSE, output=FALSE}
kraken_viral_species <- kraken_taxonomies_expanded %>%
  # Extracting all Viruses
  filter(kingdom == 'viruses') %>%

  # Dropping all rows with NA values in the species column
  filter(!is.na(species))
```

Then we define two functions both creating a vector, returning TRUE if a given **species** or **genus** name is present in the ICTV table.

```{r, code_folding = "show", message=FALSE, warning=FALSE, output=FALSE}
logical_virus_presence <- function(virus) {
  if (virus %in% taxonomy_reference$species) {
    return(TRUE)
  } else if (virus %in% taxonomy_reference$virus_name_s) {
    return(TRUE)
  } else {
    return(FALSE)
}}

logical_genus_presence <- function(genus) {
  if (genus %in% taxonomy_reference$genus) {
    return(TRUE)
  } else {
    return(FALSE)
}}
```

Now we run these functions on our subset taxonomies `kraken_viral_species`. We can then combine the results to end up with a logical vector, indicating true wherever either a kraken species or a genus matches in the ICTV table.

```{r, code_folding = "show", message=FALSE, warning=FALSE, output=FALSE}
virus_or_genus_present <- (
    map(kraken_viral_species$species, logical_virus_presence) %>% as.logical() |
    map(kraken_viral_species$genus, logical_genus_presence) %>%as.logical()) %>%

    sum()
```
<details>
  <summary>*Code explainer*</summary>
  | is a logical OR operator, which returns TRUE if either of the two arguments are TRUE. We can use this to combine the results of the two functions, to end up with a logical vector, indicating true wherever either a kraken species or a genus matches in the ICTV table. More on Boolean algebra can be found [here](https://r4ds.hadley.nz/logicals.html#fig-bool-ops:~:text=Once%20you%20have%20multiple%20logical%20vectors%2C%20you%20can%20combine%20them%20together%20using%20Boolean%20algebra.%20In%20R%2C%20%26%20is%20%E2%80%9Cand%E2%80%9D%2C%20%7C%20is%20%E2%80%9Cor%E2%80%9D%2C%20!%20is%20%E2%80%9Cnot%E2%80%9D%2C%20and%20xor()%20is%20exclusive%20or2.)
</details>

Doing this we find that **`r virus_or_genus_present`** of the **`r length(kraken_viral_species$species)`** species in the kraken2 match onto the ICTV table, either by species or genus name. This equates to **`r round((virus_or_genus_present / length(kraken_viral_species$species) *100))` %** of species in our kraken2 analyses.

We can thus conclude that we are able to pull the taxonomic information from the taxonomic table through linking on species and genus names.

### Linking entries through higher taxonomic ranks

We need two datasets to merge kraken reports with the ICTV table: 1. The first is a table with all unique species present in the kraken2 reports, subset to unique viruses. 2. The second is the ICTV table, with four additional columns teasing out the distinct information present in genome_composition. These distinct categories are i) single stranded or double stranded, ii) DNA, and RNA, iii) +, -, or +/- sense, and iv) viruses using or not using a reverse transcriptase (RT or non-RT).

#### Creating the desired kraken2 and ICTV tables
We first create the desired subset of kraken2 reports (kraken_unique_viral_species), again subsetting to viral species only.

```{r}
kraken_unique_viral_species <- kraken_taxonomies_expanded %>%
  #Subsetting to viruses
  filter(kingdom == 'viruses') %>%

  #Selecting only taxonomic columns
  select(kingdom:species) %>%

  #Turning all character variables into snake_case
  mutate_if(is.character, tolower) %>%
  mutate_if(is.character, ~str_replace_all(., ' ', '_')) %>%

  #Selecting only unique species
  distinct() %>%

  #Dropping rows where species is NA
  filter(!is.na(species)) %>%

  #Appending `kraken_` to the beginning of each column name
  rename_with(~paste0('kraken_', .x))
```

Next we create the desired ICTV table (taxonomy_genome_composition) by splitting the genome_composition column into four columns, containing i) single stranded or double stranded, ii) DNA, and RNA, iii) +, -, or +/- sense, and iv) viruses using or not using a reverse transcriptase (RT or non-RT).

```{r}
taxonomy_genome_composition <- taxonomy_reference %>%
  #Splitting genome_composition into four columns
  mutate(
    single_stranded_double_stranded = str_extract(genome_composition, 'ss|ds'),
    dna_rna = str_extract(genome_composition, 'dna|rna'),
    plus_minus = str_extract(genome_composition, '\\(\\+\\)|\\(\\-\\)|\\(\\+/-\\)'),
    rt_non_rt = str_extract(genome_composition, '-rt|non-rt')
  ) %>%

  #Appending `ictv_` to the beginning of each column name
  rename_with(~paste0('ictv_', .x))
```

### Preparing dataframe merger

We will merge the two dataframes on species, and then on genus. For sequences that do not match on species, we match on genus. But, before assigning the genome composition on the genus level we need to check that genome composition on the genus level is unique across all species within said genus. If the value is unique, we will include it. If it’s note, we will mark genus-level genome composition information as ambiguous.

We do the above with a function called call_phenotype_cols, which takes a vector of phenotypes and returns a single phenotype if all phenotypes are the same, and returns ambiguous if they are not.

```{r}
ictv_phenotype_cols = c('ictv_single_stranded_double_stranded', 'ictv_dna_rna', 'ictv_plus_minus', 'ictv_rt_non_rt')

call_phenotype_cols <- function(ictv_phenotype_cols) {
  #If all virus phenotypes in a genus are the same, return that phenotype
  if(ictv_phenotype_cols %>%
     unique() %>%
     length() == 1) {
    return(ictv_phenotype_cols %>% unique())

  #If all virus phenotypes in a genus are not the same, return ambiquous
  } else {
    return('ambiguous')
  }
}
```

Next, we create three dataframes, subsetted to contain all unique virus_name_s, species, and genus respectively. The genus dataframe is created with call_phenotype_cols to ensure that the genome composition is unique across all species within said genus.
```{r}
virus_name_composition <- taxonomy_genome_composition %>%
  filter(!duplicated(ictv_virus_name_s)) %>%
  filter(!is.na(ictv_virus_name_s))

species_composition <- taxonomy_genome_composition %>%
  filter(!duplicated(ictv_species)) %>%
  filter(!is.na(ictv_species))

ictv_phenotype_cols = c('ictv_single_stranded_double_stranded', 'ictv_dna_rna', 'ictv_plus_minus', 'ictv_rt_non_rt')

genus_composition <- taxonomy_genome_composition %>%
  group_by(ictv_genus) %>%
  summarise(
    across(all_of(ictv_phenotype_cols), call_phenotype_cols)
  ) %>%
  filter(!duplicated(ictv_genus))
```

### Merging dataframes


```{r}
viral_genome_composition <- kraken_unique_viral_species %>%
    rowwise() %>%
    mutate(gen_comp_list = case_when(
      #If the species is present in the ICTV table column virus_name_s, return the virus_name_s composition.
      kraken_species %in% virus_name_composition$ictv_virus_name_s ~

      virus_name_composition %>%
        filter(ictv_virus_name_s == kraken_species) %>%
        select(ictv_phenotype_cols) %>%
        list,

      #If the species is present in the ICTV table column species, return the species composition.
      kraken_species %in% species_composition$ictv_species ~

      species_composition %>%
        filter(ictv_species == kraken_species) %>%
        select(ictv_phenotype_cols) %>%
        list,

      #If the species is not present in the ICTV table column species, return the genus composition.
      kraken_genus %in% genus_composition$ictv_genus ~

     genus_composition %>%
        filter(ictv_genus == kraken_genus) %>%
        select(ictv_phenotype_cols) %>%
        list,
      )) %>%

    ungroup() %>%

    unnest_wider(gen_comp_list)
```
<details>
  <summary>*Code explainer*</summary>
	In summary, in the code above we do the following: First, we use `rowwise` to iterate through our `kraken_unique_viral_species` dataframe row by row. For each row we will append four values, `ictv_single_stranded_double_stranded`, `ictv_dna_rna`, `ictv_plus_minus`, and `ictv_rt_non_rt`. We then use `case_when` to go through three different if-conditions. The syntax of `case_when is as follows:

	case_when(
		condition1 ~ value1,
		condition2 ~ value2,
		condition3 ~ value3
		)

	Hence, here we check first if the species name of the current `kraken_species` row is present in the `ictv_virus_name_s` column of the `virus_name_composition` dataframe. If it is, we pull the genome composition informatoin from the respective line in the `virus_name_composition` dataframe. We do the same for the species and the genus dataframes (`species_composition` and `genus_composition`). Importantly, the values we pull from any of these  dataframe are transformed into a list; this is because `mutate` can only assign one column at a time. We thus create a column containing a list of the genome composition information for each row. Finally, we use `ungroup` to remove the grouping we created using `rowwise`. Then, we use `unnest_wider` to unnest the list we created using `case_when` and append the values to the dataframe.
</details>

# Todos

 - fix ambiguous allocation by call phenotype cols function. As of now that seems wrong.
 - Fix code some of the wording.